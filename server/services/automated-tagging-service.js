/**
 * Automated Tagging Service
 * Automatically generates tags from all available social media data
 * Users only need to validate/correct, but app works without any input
 */

const logger = require('../../utils/logger');

class AutomatedTaggingService {

  /**
   * Generate comprehensive tags from all social media data
   * @param {Object} contactData - Contact with Facebook/LinkedIn data
   * @returns {Object} Contact with automatically generated tags
   */
  async generateAllTags(contactData) {
    try {
      const autoTags = {
        location: [],
        professional: [],
        skills: [],
        interests: [],
        education: [],
        personal: [],
        social: []
      };

      // Extract tags from Facebook data
      if (contactData.facebookData) {
        const fbTags = this.extractFacebookTags(contactData.facebookData);
        this.mergeTags(autoTags, fbTags);
      }

      // Extract tags from LinkedIn data
      if (contactData.linkedinData) {
        const liTags = this.extractLinkedInTags(contactData.linkedinData);
        this.mergeTags(autoTags, liTags);
      }

      // Extract tags from work history
      if (contactData.workHistory) {
        const workTags = this.extractWorkTags(contactData.workHistory);
        this.mergeTags(autoTags, workTags);
      }

      // Extract tags from education
      if (contactData.education) {
        const eduTags = this.extractEducationTags(contactData.education);
        this.mergeTags(autoTags, eduTags);
      }

      // Extract location tags
      if (contactData.locationData) {
        const locTags = this.extractLocationTags(contactData.locationData);
        this.mergeTags(autoTags, locTags);
      }

      // Generate confidence scores for each tag
      const scoredTags = this.calculateTagConfidence(autoTags, contactData);

      // Create final tag structure
      const finalTags = this.createTagStructure(scoredTags);

      logger.info('Auto-generated tags for contact', {
        contactName: contactData.name,
        totalTags: finalTags.length,
        categories: Object.keys(autoTags).map(cat => ({
          category: cat,
          count: autoTags[cat].length
        }))
      });

      return {
        ...contactData,
        autoGeneratedTags: finalTags,
        tagCategories: autoTags,
        lastAutoTagged: new Date(),
        autoTagConfidence: this.calculateOverallConfidence(scoredTags)
      };

    } catch (error) {
      logger.error('Auto-tagging failed', {
        contactName: contactData.name,
        error: error.message
      });
      
      // Return original contact data if tagging fails
      return {
        ...contactData,
        autoGeneratedTags: [],
        autoTagError: error.message
      };
    }
  }

  /**
   * Extract comprehensive tags from Facebook profile data
   * @param {Object} facebookData - Facebook profile information
   * @returns {Object} Categorized tags from Facebook
   */
  extractFacebookTags(facebookData) {
    const tags = {
      location: [],
      professional: [],
      skills: [],
      interests: [],
      education: [],
      personal: [],
      social: []
    };

    // Location tags from Facebook
    if (facebookData.location) {
      tags.location.push({
        value: facebookData.location.name,
        source: 'facebook_location',
        confidence: 0.9
      });
    }

    if (facebookData.hometown) {
      tags.location.push({
        value: facebookData.hometown.name,
        source: 'facebook_hometown',
        confidence: 0.8
      });
    }

    // Work tags from Facebook
    if (facebookData.work && Array.isArray(facebookData.work)) {
      facebookData.work.forEach(work => {
        if (work.employer) {
          tags.professional.push({
            value: work.employer.name,
            type: 'company',
            source: 'facebook_work',
            confidence: 0.9
          });
        }
        if (work.position) {
          tags.professional.push({
            value: work.position.name,
            type: 'position',
            source: 'facebook_work',
            confidence: 0.9
          });
        }
        if (work.location) {
          tags.location.push({
            value: work.location.name,
            source: 'facebook_work_location',
            confidence: 0.7
          });
        }
      });
    }

    // Education tags from Facebook
    if (facebookData.education && Array.isArray(facebookData.education)) {
      facebookData.education.forEach(edu => {
        if (edu.school) {
          tags.education.push({
            value: edu.school.name,
            type: 'school',
            source: 'facebook_education',
            confidence: 0.9
          });
        }
        if (edu.degree) {
          tags.education.push({
            value: edu.degree.name,
            type: 'degree',
            source: 'facebook_education',
            confidence: 0.8
          });
        }
        if (edu.concentration) {
          edu.concentration.forEach(conc => {
            tags.education.push({
              value: conc.name,
              type: 'field_of_study',
              source: 'facebook_education',
              confidence: 0.8
            });
          });
        }
      });
    }

    // Interest tags from Facebook
    if (facebookData.interests && facebookData.interests.data) {
      facebookData.interests.data.forEach(interest => {
        tags.interests.push({
          value: interest.name,
          source: 'facebook_interests',
          confidence: 0.7
        });
      });
    }

    // Relationship status
    if (facebookData.relationship_status) {
      tags.personal.push({
        value: facebookData.relationship_status,
        type: 'relationship_status',
        source: 'facebook_personal',
        confidence: 0.8
      });
    }

    // Mutual friends count (social proof)
    if (facebookData.mutual_friends) {
      const mutualCount = facebookData.mutual_friends.summary?.total_count || 0;
      if (mutualCount > 0) {
        tags.social.push({
          value: `${mutualCount}_mutual_friends`,
          type: 'social_proof',
          source: 'facebook_social',
          confidence: 1.0
        });
      }
    }

    return tags;
  }

  /**
   * Extract tags from LinkedIn profile data
   * @param {Object} linkedinData - LinkedIn profile information
   * @returns {Object} Categorized tags from LinkedIn
   */
  extractLinkedInTags(linkedinData) {
    const tags = {
      location: [],
      professional: [],
      skills: [],
      interests: [],
      education: [],
      personal: [],
      social: []
    };

    // Professional experience from LinkedIn
    if (linkedinData.positions && linkedinData.positions.values) {
      linkedinData.positions.values.forEach(position => {
        if (position.company) {
          tags.professional.push({
            value: position.company.name,
            type: 'company',
            source: 'linkedin_experience',
            confidence: 0.95
          });
        }
        if (position.title) {
          tags.professional.push({
            value: position.title,
            type: 'position',
            source: 'linkedin_experience',
            confidence: 0.95
          });
        }
        if (position.summary) {
          // Extract skills/keywords from job descriptions
          const skillKeywords = this.extractSkillsFromText(position.summary);
          skillKeywords.forEach(skill => {
            tags.skills.push({
              value: skill,
              source: 'linkedin_job_description',
              confidence: 0.6
            });
          });
        }
      });
    }

    // Skills from LinkedIn
    if (linkedinData.skills && linkedinData.skills.values) {
      linkedinData.skills.values.forEach(skill => {
        tags.skills.push({
          value: skill.skill.name,
          endorsements: skill.endorsements ? skill.endorsements.total : 0,
          source: 'linkedin_skills',
          confidence: 0.9
        });
      });
    }

    // Education from LinkedIn
    if (linkedinData.educations && linkedinData.educations.values) {
      linkedinData.educations.values.forEach(edu => {
        if (edu.schoolName) {
          tags.education.push({
            value: edu.schoolName,
            type: 'school',
            source: 'linkedin_education',
            confidence: 0.95
          });
        }
        if (edu.degree) {
          tags.education.push({
            value: edu.degree,
            type: 'degree',
            source: 'linkedin_education',
            confidence: 0.9
          });
        }
        if (edu.fieldOfStudy) {
          tags.education.push({
            value: edu.fieldOfStudy,
            type: 'field_of_study',
            source: 'linkedin_education',
            confidence: 0.9
          });
        }
      });
    }

    // Location from LinkedIn
    if (linkedinData.location) {
      tags.location.push({
        value: linkedinData.location.name,
        source: 'linkedin_location',
        confidence: 0.9
      });
    }

    // Industry from LinkedIn
    if (linkedinData.industry) {
      tags.professional.push({
        value: linkedinData.industry,
        type: 'industry',
        source: 'linkedin_industry',
        confidence: 0.9
      });
    }

    // Connections count (social proof)
    if (linkedinData.numConnections) {
      tags.social.push({
        value: `${linkedinData.numConnections}_linkedin_connections`,
        type: 'social_proof',
        source: 'linkedin_social',
        confidence: 1.0
      });
    }

    return tags;
  }

  /**
   * Extract tags from work history
   * @param {Array} workHistory - Work experience data
   * @returns {Object} Categorized work tags
   */
  extractWorkTags(workHistory) {
    const tags = {
      location: [],
      professional: [],
      skills: [],
      interests: [],
      education: [],
      personal: [],
      social: []
    };

    workHistory.forEach((work, index) => {
      const isCurrent = index === 0; // Assume first entry is current

      if (work.employer) {
        tags.professional.push({
          value: work.employer,
          type: 'company',
          isCurrent: isCurrent,
          source: 'work_history',
          confidence: 0.9
        });

        // Extract industry hints from company names
        const industry = this.inferIndustryFromCompany(work.employer);
        if (industry) {
          tags.professional.push({
            value: industry,
            type: 'industry',
            source: 'inferred_from_company',
            confidence: 0.6
          });
        }
      }

      if (work.position) {
        tags.professional.push({
          value: work.position,
          type: 'position',
          isCurrent: isCurrent,
          source: 'work_history',
          confidence: 0.9
        });

        // Extract skill implications from job titles
        const impliedSkills = this.inferSkillsFromJobTitle(work.position);
        impliedSkills.forEach(skill => {
          tags.skills.push({
            value: skill,
            source: 'inferred_from_job_title',
            confidence: 0.5
          });
        });
      }

      if (work.location) {
        tags.location.push({
          value: work.location,
          source: 'work_location',
          confidence: 0.8
        });
      }

      // Calculate tenure if dates available
      if (work.startDate && work.endDate) {
        const tenure = this.calculateTenure(work.startDate, work.endDate);
        if (tenure) {
          tags.professional.push({
            value: `${tenure}_tenure`,
            type: 'experience_level',
            source: 'calculated_tenure',
            confidence: 0.8
          });
        }
      }
    });

    return tags;
  }

  /**
   * Extract tags from education data
   * @param {Array} education - Education history
   * @returns {Object} Categorized education tags
   */
  extractEducationTags(education) {
    const tags = {
      location: [],
      professional: [],
      skills: [],
      interests: [],
      education: [],
      personal: [],
      social: []
    };

    education.forEach(edu => {
      if (edu.school) {
        tags.education.push({
          value: edu.school,
          type: 'school',
          source: 'education_history',
          confidence: 0.9
        });

        // Infer prestige/ranking if known university
        const prestige = this.inferSchoolPrestige(edu.school);
        if (prestige) {
          tags.education.push({
            value: prestige,
            type: 'school_tier',
            source: 'inferred_prestige',
            confidence: 0.7
          });
        }
      }

      if (edu.degree) {
        tags.education.push({
          value: edu.degree,
          type: 'degree',
          source: 'education_history',
          confidence: 0.9
        });
      }

      if (edu.concentration) {
        edu.concentration.forEach(field => {
          tags.education.push({
            value: field,
            type: 'field_of_study',
            source: 'education_history',
            confidence: 0.9
          });

          // Infer career implications from field of study
          const careerPaths = this.inferCareerFromField(field);
          careerPaths.forEach(career => {
            tags.professional.push({
              value: career,
              type: 'career_potential',
              source: 'inferred_from_education',
              confidence: 0.5
            });
          });
        });
      }
    });

    return tags;
  }

  /**
   * Extract location-specific tags
   * @param {Object} locationData - Location information
   * @returns {Object} Categorized location tags
   */
  extractLocationTags(locationData) {
    const tags = {
      location: [],
      professional: [],
      skills: [],
      interests: [],
      education: [],
      personal: [],
      social: []
    };

    if (locationData.currentLocation) {
      tags.location.push({
        value: locationData.currentLocation.name,
        type: 'current_location',
        source: 'location_data',
        confidence: 0.9
      });

      // Extract city/state/country components
      const locationParts = this.parseLocation(locationData.currentLocation.name);
      locationParts.forEach(part => {
        tags.location.push({
          value: part.value,
          type: part.type,
          source: 'parsed_location',
          confidence: 0.8
        });
      });

      // Infer local knowledge
      tags.interests.push({
        value: `local_${locationParts[0]?.value?.toLowerCase().replace(/\s+/g, '_')}`,
        type: 'local_knowledge',
        source: 'inferred_local_knowledge',
        confidence: 0.7
      });
    }

    if (locationData.hometown) {
      tags.location.push({
        value: locationData.hometown.name,
        type: 'hometown',
        source: 'location_data',
        confidence: 0.8
      });
    }

    // All cities the person has lived/worked in
    if (locationData.cities && locationData.cities.length > 0) {
      locationData.cities.forEach(city => {
        tags.location.push({
          value: city,
          type: 'familiar_location',
          source: 'location_history',
          confidence: 0.6
        });
      });
    }

    return tags;
  }

  /**
   * Extract skills from job description text using NLP
   * @param {string} text - Job description or summary text
   * @returns {Array} Extracted skills
   */
  extractSkillsFromText(text) {
    if (!text) return [];

    const skillKeywords = [
      // Technical skills
      'javascript', 'python', 'java', 'react', 'node.js', 'sql', 'aws', 'docker',
      'kubernetes', 'machine learning', 'data analysis', 'excel', 'powerpoint',
      
      // Soft skills
      'leadership', 'management', 'communication', 'teamwork', 'problem solving',
      'strategic planning', 'project management', 'negotiation', 'sales',
      
      // Industry skills
      'marketing', 'finance', 'accounting', 'legal', 'hr', 'operations',
      'product management', 'business development', 'consulting'
    ];

    const foundSkills = [];
    const lowerText = text.toLowerCase();

    skillKeywords.forEach(skill => {
      if (lowerText.includes(skill)) {
        foundSkills.push(skill);
      }
    });

    return foundSkills;
  }

  /**
   * Infer industry from company name
   * @param {string} companyName - Company name
   * @returns {string} Inferred industry
   */
  inferIndustryFromCompany(companyName) {
    const industryKeywords = {
      'tech': ['google', 'facebook', 'amazon', 'microsoft', 'apple', 'netflix', 'uber', 'airbnb', 'tech', 'software'],
      'finance': ['goldman', 'morgan', 'bank', 'capital', 'finance', 'credit', 'investment'],
      'consulting': ['mckinsey', 'bain', 'bcg', 'deloitte', 'pwc', 'accenture', 'consulting'],
      'healthcare': ['hospital', 'medical', 'health', 'pharma', 'bio'],
      'education': ['university', 'college', 'school', 'education']
    };

    const lowerCompany = companyName.toLowerCase();
    
    for (const [industry, keywords] of Object.entries(industryKeywords)) {
      if (keywords.some(keyword => lowerCompany.includes(keyword))) {
        return industry;
      }
    }

    return null;
  }

  /**
   * Infer skills from job title
   * @param {string} jobTitle - Job title
   * @returns {Array} Inferred skills
   */
  inferSkillsFromJobTitle(jobTitle) {
    const titleSkillMap = {
      'engineer': ['programming', 'problem solving', 'technical analysis'],
      'manager': ['leadership', 'management', 'communication'],
      'developer': ['programming', 'software development', 'debugging'],
      'designer': ['design', 'creativity', 'visual communication'],
      'analyst': ['data analysis', 'excel', 'research'],
      'sales': ['sales', 'negotiation', 'communication'],
      'marketing': ['marketing', 'communication', 'creativity']
    };

    const skills = [];
    const lowerTitle = jobTitle.toLowerCase();

    for (const [keyword, skillList] of Object.entries(titleSkillMap)) {
      if (lowerTitle.includes(keyword)) {
        skills.push(...skillList);
      }
    }

    return skills;
  }

  /**
   * Calculate confidence scores for generated tags
   * @param {Object} tags - Categorized tags
   * @param {Object} contactData - Original contact data
   * @returns {Object} Tags with confidence scores
   */
  calculateTagConfidence(tags, contactData) {
    const scoredTags = {};

    for (const [category, tagList] of Object.entries(tags)) {
      scoredTags[category] = tagList.map(tag => {
        let adjustedConfidence = tag.confidence || 0.5;

        // Boost confidence for verified sources
        if (tag.source.includes('linkedin')) {
          adjustedConfidence += 0.1;
        }
        if (tag.source.includes('facebook')) {
          adjustedConfidence += 0.05;
        }

        // Boost confidence for multiple source confirmation
        const otherSources = this.findOtherSources(tag.value, tags);
        if (otherSources.length > 0) {
          adjustedConfidence += 0.1 * otherSources.length;
        }

        // Cap confidence at 1.0
        adjustedConfidence = Math.min(adjustedConfidence, 1.0);

        return {
          ...tag,
          finalConfidence: adjustedConfidence
        };
      });
    }

    return scoredTags;
  }

  /**
   * Create final tag structure for storage
   * @param {Object} scoredTags - Tags with confidence scores
   * @returns {Array} Final tag array
   */
  createTagStructure(scoredTags) {
    const finalTags = [];

    for (const [category, tagList] of Object.entries(scoredTags)) {
      tagList.forEach(tag => {
        finalTags.push({
          value: tag.value,
          category: category,
          type: tag.type || 'general',
          source: tag.source,
          confidence: tag.finalConfidence,
          isCurrent: tag.isCurrent || false,
          endorsements: tag.endorsements || 0,
          createdAt: new Date(),
          validatedAt: null,
          validatedBy: null
        });
      });
    }

    // Sort by confidence (highest first)
    return finalTags.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Merge tag categories
   * @param {Object} targetTags - Target tag object
   * @param {Object} sourceTags - Source tag object
   */
  mergeTags(targetTags, sourceTags) {
    for (const [category, tagList] of Object.entries(sourceTags)) {
      if (!targetTags[category]) {
        targetTags[category] = [];
      }
      targetTags[category].push(...tagList);
    }
  }

  /**
   * Find other sources that mention the same tag value
   * @param {string} tagValue - Tag value to search for
   * @param {Object} allTags - All categorized tags
   * @returns {Array} Other sources mentioning this tag
   */
  findOtherSources(tagValue, allTags) {
    const sources = [];
    
    for (const tagList of Object.values(allTags)) {
      tagList.forEach(tag => {
        if (tag.value === tagValue && !sources.includes(tag.source)) {
          sources.push(tag.source);
        }
      });
    }

    return sources.slice(1); // Remove the first (original) source
  }

  /**
   * Calculate overall confidence for contact's auto-tagging
   * @param {Object} scoredTags - Tags with confidence scores
   * @returns {number} Overall confidence score
   */
  calculateOverallConfidence(scoredTags) {
    let totalConfidence = 0;
    let totalTags = 0;

    for (const tagList of Object.values(scoredTags)) {
      tagList.forEach(tag => {
        totalConfidence += tag.finalConfidence;
        totalTags++;
      });
    }

    return totalTags > 0 ? totalConfidence / totalTags : 0;
  }

  /**
   * Parse location string into components
   * @param {string} location - Location string
   * @returns {Array} Location components
   */
  parseLocation(location) {
    const parts = location.split(',').map(part => part.trim());
    const components = [];

    if (parts.length >= 1) {
      components.push({ value: parts[0], type: 'city' });
    }
    if (parts.length >= 2) {
      components.push({ value: parts[1], type: 'state_province' });
    }
    if (parts.length >= 3) {
      components.push({ value: parts[2], type: 'country' });
    }

    return components;
  }

  /**
   * Calculate tenure from dates
   * @param {string} startDate - Start date
   * @param {string} endDate - End date
   * @returns {string} Tenure description
   */
  calculateTenure(startDate, endDate) {
    // Simplified tenure calculation
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end - start);
    const diffYears = Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 365));

    if (diffYears < 1) return 'short_tenure';
    if (diffYears < 3) return 'medium_tenure';
    return 'long_tenure';
  }

  /**
   * Infer school prestige (simplified)
   * @param {string} school - School name
   * @returns {string} Prestige tier
   */
  inferSchoolPrestige(school) {
    const ivyLeague = ['harvard', 'yale', 'princeton', 'columbia', 'upenn', 'dartmouth', 'brown', 'cornell'];
    const topTech = ['mit', 'stanford', 'caltech'];
    
    const lowerSchool = school.toLowerCase();
    
    if (ivyLeague.some(ivy => lowerSchool.includes(ivy)) || topTech.some(tech => lowerSchool.includes(tech))) {
      return 'tier_1_university';
    }
    
    return null;
  }

  /**
   * Infer career paths from field of study
   * @param {string} field - Field of study
   * @returns {Array} Potential career paths
   */
  inferCareerFromField(field) {
    const fieldCareerMap = {
      'computer science': ['software engineer', 'data scientist', 'product manager'],
      'business': ['consultant', 'analyst', 'manager'],
      'finance': ['investment banker', 'financial analyst', 'trader'],
      'marketing': ['marketing manager', 'brand manager', 'digital marketer'],
      'engineering': ['engineer', 'technical lead', 'engineering manager']
    };

    const lowerField = field.toLowerCase();
    
    for (const [studyField, careers] of Object.entries(fieldCareerMap)) {
      if (lowerField.includes(studyField)) {
        return careers;
      }
    }

    return [];
  }
}

module.exports = new AutomatedTaggingService();