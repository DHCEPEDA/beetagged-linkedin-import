// --- Facebook Import Logic (Conceptual - Requires Backend) ---
const importFacebookBtn = document.getElementById('importFacebookBtn');

importFacebookBtn.addEventListener('click', async () => {
    // 1. Initiate OAuth flow (likely redirect to your backend, which then redirects to FB)
    // window.location.href = '/auth/facebook'; // Example redirect to backend
    alert("Facebook import initiated. This will likely involve a popup or redirect for Facebook login.");

    // 2. After user authenticates and backend fetches data,
    //    the backend would send the Facebook contacts back to the client,
    //    or the client would fetch them from a backend endpoint.

    // --- MOCKUP: Simulating receiving Facebook data from backend ---
    // In a real app, this data would come from an API call to your backend
    // after successful Facebook authentication and data retrieval.
    const mockFacebookContacts = await fetchMockFacebookContacts();

    // 3. Consolidate and display
    consolidateAndAddContacts(mockFacebookContacts, 'Facebook');
    displayContacts(getConsolidatedContacts()); // Display the updated, consolidated list
});

// Mock function to simulate fetching FB contacts (replace with actual API call)
async function fetchMockFacebookContacts() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve([
                { name: "Alice Wonderland", mutualFriends: 10 /* other FB fields */ },
                { name: "Charles Xavier", hometown: "New York" /* other FB fields */ }
            ]);
        }, 1000);
    });
}


// --- Contact Consolidation and Merging Logic ---
function consolidateAndAddContacts(newContacts, source) {
    newContacts.forEach(newContact => {
        // Attempt to find an existing contact (e.g., by name - very basic, improve this)
        let existingContact = allContacts.find(c => c.name.toLowerCase() === newContact.name.toLowerCase());

        if (existingContact) {
            // Contact exists, merge data
            if (!existingContact.sources) existingContact.sources = [];
            if (!existingContact.sources.includes(source)) {
                existingContact.sources.push(source);
            }

            // Add source-specific data
            // Example: if LinkedIn data is an object, and FB data is an object
            if (source === 'LinkedIn') {
                if (!existingContact.linkedInData) existingContact.linkedInData = {};
                Object.assign(existingContact.linkedInData, newContact); // newContact here is the parsed LI contact
                delete existingContact.linkedInData.name; // Avoid duplicating name
                delete existingContact.linkedInData.source;
            } else if (source === 'Facebook') {
                if (!existingContact.facebookData) existingContact.facebookData = {};
                Object.assign(existingContact.facebookData, newContact); // newContact here is the parsed FB contact
                delete existingContact.facebookData.name;
                delete existingContact.facebookData.source;
            }
            // If you want simpler structure and just add new fields:
            // Object.keys(newContact).forEach(key => {
            //     if (key !== 'name' && key !== 'source') { // Don't overwrite common fields like 'name' carelessly
            //         if (!existingContact[key]) {
            //             existingContact[key] = newContact[key];
            //         } else {
            //             // Handle "populate that info in a separate line" - this means display logic needs to check source
            //             // Or store as an array if multiple values for the same key from different sources
            //             if (!Array.isArray(existingContact[key])) {
            //                 existingContact[key] = [existingContact[key]];
            //             }
            //             if (!existingContact[key].some(item => JSON.stringify(item) === JSON.stringify(newContact[key]))) { // Avoid duplicate entries
            //                  existingContact[key].push({value: newContact[key], source: source});
            //             }
            //         }
            //     }
            // });


        } else {
            // New contact, add it with its source
            const contactToAdd = { ...newContact, source: source, sources: [source] };
            if (source === 'LinkedIn') {
                contactToAdd.linkedInData = { ...newContact };
                delete contactToAdd.linkedInData.name;
                delete contactToAdd.linkedInData.source;
            } else if (source === 'Facebook') {
                contactToAdd.facebookData = { ...newContact };
                delete contactToAdd.facebookData.name;
                delete contactToAdd.facebookData.source;
            }
            allContacts.push(contactToAdd);
        }
    });

    // Re-assign allContacts to ensure reactivity if you're using a framework,
    // or just rely on displayContacts being called.
    allContacts = [...allContacts];
}


// --- Updated getConsolidatedContacts and displayContacts to handle new structure ---
function getConsolidatedContacts() {
    // This function will now simply return the allContacts array,
    // as consolidation happens during the import process.
    // You might add more sophisticated de-duplication here later if needed.
    return allContacts;
}

function displayContacts(contactsToDisplay) {
    contactListContainer.innerHTML = ''; // Clear previous list

    if (contactsToDisplay.length === 0) {
        contactListContainer.innerHTML = '<p>No contacts to display.</p>';
        return;
    }

    const ul = document.createElement('ul');
    contactsToDisplay.forEach(contact => {
        const li = document.createElement('li');
        let contactTitle = `${contact.name}`;
        if (contact.sources && contact.sources.length > 0) {
            contactTitle += ` (${contact.sources.join(', ')})`;
        }
        li.innerHTML = `<strong>${contactTitle}</strong>`;

        // Display LinkedIn Data
        if (contact.linkedInData) {
            const liDetails = document.createElement('div');
            liDetails.style.marginLeft = "15px";
            liDetails.style.fontSize = "0.9em";
            Object.keys(contact.linkedInData).forEach(key => {
                if (contact.linkedInData[key]) { // Check if field has value
                    const detailP = document.createElement('p');
                    detailP.style.margin = "2px 0";
                    detailP.textContent = `LI - ${key}: ${contact.linkedInData[key]}`;
                    liDetails.appendChild(detailP);
                }
            });
            li.appendChild(liDetails);
        }

        // Display Facebook Data
        if (contact.facebookData) {
            const fbDetails = document.createElement('div');
            fbDetails.style.marginLeft = "15px";
            fbDetails.style.fontSize = "0.9em";
            Object.keys(contact.facebookData).forEach(key => {
                 if (contact.facebookData[key]) { // Check if field has value
                    const detailP = document.createElement('p');
                    detailP.style.margin = "2px 0";
                    detailP.textContent = `FB - ${key}: ${contact.facebookData[key]}`;
                    fbDetails.appendChild(detailP);
                }
            });
            li.appendChild(fbDetails);
        }

        // Handle other general publicly available data fields similarly if they are not source-specific
        // For example, if you have a 'company' field that could come from either and you merge it:
        // if (contact.company) {
        //     const companyP = document.createElement('p');
        //     companyP.textContent = `Company: ${contact.company}`;
        //     li.appendChild(companyP);
        // }

        ul.appendChild(li);
    });
    contactListContainer.appendChild(ul);
}


// Adjust the LinkedIn import to use the new consolidation logic
// (Modify the 'reader.onload' part of LinkedIn import)
// Inside your importLinkedInBtn event listener's reader.onload:
// ...
// const parsedLinkedInContacts = parseLinkedInData(fileContent);
// consolidateAndAddContacts(parsedLinkedInContacts, 'LinkedIn');
// displayContacts(getConsolidatedContacts());
// ...

// Make sure to call consolidateAndAddContacts in your LinkedIn import function:
// Inside importLinkedInBtn's reader.onload:
// ...
// const parsedLinkedInContacts = parseLinkedInData(fileContent);
// // Instead of:
// // parsedLinkedInContacts.forEach(contact => contact.source = 'LinkedIn');
// // allContacts = allContacts.concat(parsedLinkedInContacts);
// // Use:
// consolidateAndAddContacts(parsedLinkedInContacts, 'LinkedIn');
// displayContacts(getConsolidatedContacts()); // Display the updated, consolidated list
// ...
