Replit Project Structure
Create a new Node.js Replit project with this structure:

beetagged-backend/
├── package.json
├── server.js (main entry point)
├── config/
│   ├── database.js
│   └── constants.js
├── routes/
│   ├── linkedin.js
│   ├── facebook.js
│   ├── contacts.js
│   ├── search.js
│   └── ranking.js
├── models/
│   ├── Contact.js
│   ├── User.js
│   └── Ranking.js
├── services/
│   ├── linkedinService.js
│   ├── facebookService.js
│   ├── openaiService.js
│   └── searchService.js
├── utils/
│   ├── dataProcessor.js
│   └── validators.js
└── middleware/
    ├── auth.js
    └── cors.js
Key Files to Create in Replit
1. package.json

{
  "name": "beetagged-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "axios": "^1.6.0",
    "openai": "^4.20.0",
    "multer": "^1.4.5",
    "compression": "^1.7.4",
    "express-rate-limit": "^7.1.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
2. server.js (Main Entry Point)

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(helmet());
app.use(compression());
app.use(morgan('combined'));
app.use(cors({
  origin: ['http://localhost:8080', 'https://your-lovable-app.lovable.app'],
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Database connection
mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('MongoDB connected'))
  .catch(err => console.error('MongoDB connection error:', err));

// Routes
app.use('/api/linkedin', require('./routes/linkedin'));
app.use('/api/facebook', require('./routes/facebook'));
app.use('/api/contacts', require('./routes/contacts'));
app.use('/api/search', require('./routes/search'));
app.use('/api/ranking', require('./routes/ranking'));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

app.listen(PORT, () => {
  console.log(`BeeTagged Backend running on port ${PORT}`);
});
3. routes/contacts.js (Contact Management)

const express = require('express');
const router = express.Router();
const Contact = require('../models/Contact');
const { processContactData } = require('../utils/dataProcessor');

// Get all contacts for a user
router.get('/:userId', async (req, res) => {
  try {
    const contacts = await Contact.find({ userId: req.params.userId });
    res.json(contacts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Add new contact
router.post('/', async (req, res) => {
  try {
    const processedData = processContactData(req.body);
    const contact = new Contact(processedData);
    await contact.save();
    res.status(201).json(contact);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Bulk import contacts
router.post('/bulk-import', async (req, res) => {
  try {
    const { contacts, userId } = req.body;
    const processedContacts = contacts.map(contact => 
      processContactData({ ...contact, userId })
    );
    
    const result = await Contact.insertMany(processedContacts);
    res.json({ imported: result.length, contacts: result });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;
4. routes/linkedin.js (LinkedIn Integration)

const express = require('express');
const router = express.Router();
const { fetchLinkedInContacts, getLinkedInProfile } = require('../services/linkedinService');

// OAuth callback handler
router.get('/oauth/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    // Handle LinkedIn OAuth callback
    const accessToken = await exchangeCodeForToken(code);
    res.json({ success: true, accessToken });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Fetch user's LinkedIn connections
router.post('/import-contacts', async (req, res) => {
  try {
    const { accessToken, userId } = req.body;
    const contacts = await fetchLinkedInContacts(accessToken);
    
    // Process and save contacts
    const processedContacts = contacts.map(contact => ({
      ...contact,
      userId,
      source: 'linkedin',
      importedAt: new Date()
    }));
    
    res.json({ imported: processedContacts.length, contacts: processedContacts });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
5. routes/search.js (AI-Powered Search)

const express = require('express');
const router = express.Router();
const { performAISearch } = require('../services/searchService');
const Contact = require('../models/Contact');

// AI-powered contact search
router.post('/ai-search', async (req, res) => {
  try {
    const { query, userId, filters = {} } = req.body;
    
    // Get user's contacts
    const userContacts = await Contact.find({ userId });
    
    // Perform AI search
    const searchResults = await performAISearch(query, userContacts, filters);
    
    res.json({
      query,
      totalResults: searchResults.length,
      results: searchResults
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Traditional search with filters
router.post('/filter', async (req, res) => {
  try {
    const { userId, filters } = req.body;
    
    let query = { userId };
    
    if (filters.skills) {
      query.skills = { $in: filters.skills };
    }
    if (filters.location) {
      query.location = new RegExp(filters.location, 'i');
    }
    if (filters.company) {
      query.company = new RegExp(filters.company, 'i');
    }
    
    const contacts = await Contact.find(query);
    res.json(contacts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
6. services/openaiService.js (OpenAI Integration)

const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

async function generateSearchEmbedding(query) {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: query,
    });
    return response.data[0].embedding;
  } catch (error) {
    console.error('OpenAI embedding error:', error);
    throw error;
  }
}

async function rankContacts(query, contacts) {
  try {
    const prompt = `
    Given this search query: "${query}"
    
    Rank these contacts from most to least relevant:
    ${contacts.map((c, i) => `${i+1}. ${c.name} - ${c.title} at ${c.company} (${c.skills?.join(', ')})`).join('\n')}
    
    Return only the numbers in order of relevance (most relevant first).
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-4.1-2025-04-14",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 200
    });

    const ranking = response.choices[0].message.content
      .split(/[\s,]+/)
      .map(n => parseInt(n.trim()))
      .filter(n => !isNaN(n));

    return ranking.map(index => contacts[index - 1]).filter(Boolean);
  } catch (error) {
    console.error('OpenAI ranking error:', error);
    return contacts; // Return original order if AI fails
  }
}

module.exports = {
  generateSearchEmbedding,
  rankContacts
};
7. models/Contact.js (MongoDB Schema)

const mongoose = require('mongoose');

const contactSchema = new mongoose.Schema({
  userId: { type: String, required: true, index: true },
  name: { type: String, required: true },
  email: String,
  phone: String,
  title: String,
  company: String,
  location: String,
  skills: [String],
  source: { type: String, enum: ['linkedin', 'facebook', 'manual'], default: 'manual' },
  profileUrl: String,
  profileImage: String,
  bio: String,
  connections: Number,
  lastInteraction: Date,
  tags: [String],
  notes: String,
  ranking: {
    coding: Number,
    cooking: Number,
    intelligence: Number,
    networking: Number,
    leadership: Number
  },
  importedAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// Index for search performance
contactSchema.index({ userId: 1, name: 'text', title: 'text', company: 'text' });

module.exports = mongoose.model('Contact', contactSchema);
Environment Variables (.env file)
Create a .env file in your Replit project:

MONGODB_URI=your_mongodb_connection_string
OPENAI_API_KEY=your_openai_api_key
LINKEDIN_CLIENT_ID=your_linkedin_app_id
LINKEDIN_CLIENT_SECRET=your_linkedin_app_secret
FACEBOOK_APP_ID=your_facebook_app_id
FACEBOOK_APP_SECRET=your_facebook_app_secret
JWT_SECRET=your_jwt_secret_key
Next Steps
Create the Replit project with these files
Set up your MongoDB connection string
Add your API keys to the environment variables
Test the health endpoint: https://your-replit-url.repl.co/health
Once this is running, your Lovable frontend can communicate with endpoints like:

POST /api/contacts/bulk-import
POST /api/search/ai-search
POST /api/linkedin/import-contacts