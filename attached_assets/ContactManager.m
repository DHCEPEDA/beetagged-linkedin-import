//
//  ContactManager.m
//  Bees Chest
//
//  Created by Billy Irwin on 1/17/14.
//  Copyright (c) 2014 Arbrr. All rights reserved.
//

#import "ContactManager.h"
#import <AddressBook/AddressBook.h>
#import <Contacts/Contacts.h>
#import "Contact.h"
#import "Tag.h"
#import "TagIndex.h"
#import "Constants.h"

// Private properties
@interface ContactManager ()
@property (nonatomic, readwrite) BOOL isLoadingContacts;
@property (nonatomic, readwrite) BOOL isEnhancingWithFacebook;
@property (nonatomic, readwrite) CGFloat enhancementProgress;
@property (strong, nonatomic) NSURLSession *urlSession;
@property (strong, nonatomic) NSString *serverBaseURL;
@end

@implementation ContactManager

+ (ContactManager *)singleton {
    static ContactManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        _contacts = [NSMutableArray array];
        _tagIndex = [NSMutableDictionary dictionary];
        _autoGeneratedTags = [NSMutableArray array];
        _isLoadingContacts = NO;
        _isEnhancingWithFacebook = NO;
        _enhancementProgress = 0.0f;
        _urlSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
        
        // Set server URL - this should match your Replit server
        _serverBaseURL = @"https://beetagged-server.replit.app";
        
        // Load any saved contacts
        [self loadContactsFromLocalStorage];
    }
    return self;
}

#pragma mark - Contact Loading

- (void)loadContactsFromAddressBookWithCompletion:(void(^)(BOOL success, NSError *error))completion {
    self.isLoadingContacts = YES;
    
    // Using newer CNContacts framework (iOS 9+)
    if (@available(iOS 9.0, *)) {
        [self loadContactsUsingCNContactWithCompletion:completion];
    } else {
        // Fall back to older AddressBook framework
        [self loadContactsUsingAddressBookWithCompletion:completion];
    }
}

// Modern Contacts framework (iOS 9+)
- (void)loadContactsUsingCNContactWithCompletion:(void(^)(BOOL success, NSError *error))completion {
    if (@available(iOS 9.0, *)) {
        CNContactStore *contactStore = [[CNContactStore alloc] init];
        
        [contactStore requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError *error) {
            if (!granted) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.isLoadingContacts = NO;
                    NSError *accessError = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                                               code:403 
                                                           userInfo:@{NSLocalizedDescriptionKey: @"Access to contacts denied"}];
                    if (completion) completion(NO, accessError);
                });
                return;
            }
            
            NSArray *keys = @[CNContactGivenNameKey, CNContactFamilyNameKey, CNContactEmailAddressesKey, 
                              CNContactPhoneNumbersKey, CNContactImageDataKey, CNContactThumbnailImageDataKey,
                              CNContactOrganizationNameKey, CNContactJobTitleKey];
            
            CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:keys];
            
            NSError *fetchError;
            NSMutableArray *newContacts = [NSMutableArray array];
            
            [contactStore enumerateContactsWithFetchRequest:request error:&fetchError usingBlock:^(CNContact *cnContact, BOOL *stop) {
                Contact *contact = [[Contact alloc] init];
                
                // Set basic info
                contact.firstName = cnContact.givenName;
                contact.lastName = cnContact.familyName;
                contact.organization = cnContact.organizationName;
                contact.jobTitle = cnContact.jobTitle;
                
                // Thumbnail/image
                if (cnContact.thumbnailImageData) {
                    contact.thumbnailImage = [UIImage imageWithData:cnContact.thumbnailImageData];
                }
                
                // Get primary email
                if (cnContact.emailAddresses.count > 0) {
                    CNLabeledValue *emailValue = cnContact.emailAddresses[0];
                    contact.email = emailValue.value;
                }
                
                // Get primary phone
                if (cnContact.phoneNumbers.count > 0) {
                    CNLabeledValue *phoneValue = cnContact.phoneNumbers[0];
                    CNPhoneNumber *phoneNumber = phoneValue.value;
                    contact.phoneNumber = phoneNumber.stringValue;
                }
                
                // Add to our array
                [newContacts addObject:contact];
            }];
            
            if (fetchError) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.isLoadingContacts = NO;
                    if (completion) completion(NO, fetchError);
                });
                return;
            }
            
            // Update our contacts array on main thread
            dispatch_async(dispatch_get_main_queue(), ^{
                self.contacts = [NSMutableArray arrayWithArray:newContacts];
                self.isLoadingContacts = NO;
                [self saveContactsToLocalStorage];
                if (completion) completion(YES, nil);
            });
        }];
    }
}

// Legacy AddressBook framework (pre-iOS 9)
- (void)loadContactsUsingAddressBookWithCompletion:(void(^)(BOOL success, NSError *error))completion {
    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, NULL);
    
    ABAddressBookRequestAccessWithCompletion(addressBook, ^(bool granted, CFErrorRef error) {
        if (!granted) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isLoadingContacts = NO;
                NSError *accessError = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                                           code:403 
                                                       userInfo:@{NSLocalizedDescriptionKey: @"Access to contacts denied"}];
                if (completion) completion(NO, accessError);
            });
            return;
        }
        
        NSMutableArray *newContacts = [NSMutableArray array];
        
        CFArrayRef allPeople = ABAddressBookCopyArrayOfAllPeople(addressBook);
        CFIndex count = CFArrayGetCount(allPeople);
        
        for (CFIndex i = 0; i < count; i++) {
            ABRecordRef person = CFArrayGetValueAtIndex(allPeople, i);
            
            Contact *contact = [[Contact alloc] init];
            
            // Get name
            NSString *firstName = (__bridge_transfer NSString*)ABRecordCopyValue(person, kABPersonFirstNameProperty);
            NSString *lastName = (__bridge_transfer NSString*)ABRecordCopyValue(person, kABPersonLastNameProperty);
            contact.firstName = firstName ?: @"";
            contact.lastName = lastName ?: @"";
            
            // Get organization
            NSString *organization = (__bridge_transfer NSString*)ABRecordCopyValue(person, kABPersonOrganizationProperty);
            contact.organization = organization ?: @"";
            
            // Get job title
            NSString *jobTitle = (__bridge_transfer NSString*)ABRecordCopyValue(person, kABPersonJobTitleProperty);
            contact.jobTitle = jobTitle ?: @"";
            
            // Get primary email
            ABMultiValueRef emails = ABRecordCopyValue(person, kABPersonEmailProperty);
            if (ABMultiValueGetCount(emails) > 0) {
                contact.email = (__bridge_transfer NSString*)ABMultiValueCopyValueAtIndex(emails, 0);
            }
            CFRelease(emails);
            
            // Get primary phone
            ABMultiValueRef phones = ABRecordCopyValue(person, kABPersonPhoneProperty);
            if (ABMultiValueGetCount(phones) > 0) {
                contact.phoneNumber = (__bridge_transfer NSString*)ABMultiValueCopyValueAtIndex(phones, 0);
            }
            CFRelease(phones);
            
            // Get image
            if (ABPersonHasImageData(person)) {
                NSData *imageData = (__bridge_transfer NSData*)ABPersonCopyImageDataWithFormat(person, kABPersonImageFormatThumbnail);
                contact.thumbnailImage = [UIImage imageWithData:imageData];
            }
            
            [newContacts addObject:contact];
        }
        
        CFRelease(allPeople);
        CFRelease(addressBook);
        
        // Update our contacts array on main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            self.contacts = [NSMutableArray arrayWithArray:newContacts];
            self.isLoadingContacts = NO;
            [self saveContactsToLocalStorage];
            if (completion) completion(YES, nil);
        });
    });
}

#pragma mark - Facebook Integration

- (void)setFacebookAccessToken:(NSString *)token {
    _facebookAccessToken = token;
    // Save to user defaults
    [[NSUserDefaults standardUserDefaults] setObject:token forKey:@"BeeTagged_FacebookAccessToken"];
    [[NSUserDefaults standardUserDefaults] synchronize];
}

- (BOOL)hasFacebookAccessToken {
    if (_facebookAccessToken) {
        return YES;
    }
    
    // Try to load from user defaults
    NSString *savedToken = [[NSUserDefaults standardUserDefaults] objectForKey:@"BeeTagged_FacebookAccessToken"];
    if (savedToken) {
        _facebookAccessToken = savedToken;
        return YES;
    }
    
    return NO;
}

- (void)clearFacebookAccessToken {
    _facebookAccessToken = nil;
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"BeeTagged_FacebookAccessToken"];
    [[NSUserDefaults standardUserDefaults] synchronize];
}

- (void)enhanceContactsWithFacebookData:(void(^)(BOOL success, NSArray *enhancedContacts, NSError *error))completion {
    if (!self.facebookAccessToken) {
        NSError *error = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                             code:401 
                                         userInfo:@{NSLocalizedDescriptionKey: @"Facebook access token is required"}];
        if (completion) completion(NO, nil, error);
        return;
    }
    
    if (self.contacts.count == 0) {
        NSError *error = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                             code:400 
                                         userInfo:@{NSLocalizedDescriptionKey: @"No contacts to enhance"}];
        if (completion) completion(NO, nil, error);
        return;
    }
    
    self.isEnhancingWithFacebook = YES;
    self.enhancementProgress = 0.0f;
    
    // Prepare contacts in the format expected by our server
    NSMutableArray *contactsArray = [NSMutableArray array];
    
    for (Contact *contact in self.contacts) {
        NSMutableDictionary *contactDict = [NSMutableDictionary dictionary];
        
        // Set basic info
        [contactDict setObject:[NSString stringWithFormat:@"%@ %@", contact.firstName ?: @"", contact.lastName ?: @""] forKey:@"name"];
        
        if (contact.email) {
            [contactDict setObject:contact.email forKey:@"email"];
        }
        
        if (contact.phoneNumber) {
            [contactDict setObject:contact.phoneNumber forKey:@"phoneNumber"];
        }
        
        [contactsArray addObject:contactDict];
    }
    
    // Prepare request data
    NSDictionary *requestData = @{
        @"contacts": contactsArray,
        @"facebookToken": self.facebookAccessToken
    };
    
    // Convert to JSON
    NSError *jsonError;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:requestData options:0 error:&jsonError];
    
    if (jsonError) {
        self.isEnhancingWithFacebook = NO;
        if (completion) completion(NO, nil, jsonError);
        return;
    }
    
    // Create request to our server
    NSString *urlString = [NSString stringWithFormat:@"%@/api/contacts/enhance-with-facebook", self.serverBaseURL];
    NSURL *url = [NSURL URLWithString:urlString];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    [request setHTTPMethod:@"POST"];
    [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    [request setHTTPBody:jsonData];
    
    NSURLSessionDataTask *task = [self.urlSession dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        if (error) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isEnhancingWithFacebook = NO;
                if (completion) completion(NO, nil, error);
            });
            return;
        }
        
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        if (httpResponse.statusCode != 200) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isEnhancingWithFacebook = NO;
                NSString *errorMessage = [NSString stringWithFormat:@"Server returned status code %ld", (long)httpResponse.statusCode];
                NSError *serverError = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                                          code:httpResponse.statusCode 
                                                      userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                if (completion) completion(NO, nil, serverError);
            });
            return;
        }
        
        // Parse response
        NSError *jsonError;
        NSDictionary *responseDict = [NSJSONSerialization JSONObjectWithData:data options:0 error:&jsonError];
        
        if (jsonError) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isEnhancingWithFacebook = NO;
                if (completion) completion(NO, nil, jsonError);
            });
            return;
        }
        
        // Check for success
        if (![[responseDict objectForKey:@"success"] boolValue]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.isEnhancingWithFacebook = NO;
                NSString *errorMessage = [responseDict objectForKey:@"message"] ?: @"Unknown server error";
                NSError *serverError = [NSError errorWithDomain:@"BeeTaggedErrorDomain" 
                                                          code:500 
                                                      userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                if (completion) completion(NO, nil, serverError);
            });
            return;
        }
        
        // Process the enhanced contacts
        NSArray *enhancedContacts = [responseDict objectForKey:@"contacts"];
        
        // Update our contacts with the enhanced data
        [self updateContactsWithFacebookData:enhancedContacts];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self.isEnhancingWithFacebook = NO;
            self.enhancementProgress = 1.0f;
            [self saveContactsToLocalStorage];
            if (completion) completion(YES, self.contacts, nil);
        });
    }];
    
    [task resume];
}

- (void)updateContactsWithFacebookData:(NSArray *)enhancedContacts {
    // This method updates our existing Contact objects with the data from Facebook
    NSMutableDictionary *contactsByEmail = [NSMutableDictionary dictionary];
    NSMutableDictionary *contactsByName = [NSMutableDictionary dictionary];
    
    // First, create dictionaries for lookup
    for (int i = 0; i < self.contacts.count; i++) {
        Contact *contact = self.contacts[i];
        
        // Create lookup by email
        if (contact.email) {
            [contactsByEmail setObject:@(i) forKey:contact.email.lowercaseString];
        }
        
        // Create lookup by name
        NSString *fullName = [NSString stringWithFormat:@"%@ %@", contact.firstName ?: @"", contact.lastName ?: @""];
        if (fullName.length > 1) {
            [contactsByName setObject:@(i) forKey:fullName.lowercaseString];
        }
    }
    
    // Now update contacts with Facebook data
    for (NSDictionary *enhancedContact in enhancedContacts) {
        // Skip if not matched
        if (![[enhancedContact objectForKey:@"matched"] boolValue]) {
            continue;
        }
        
        // Find the corresponding contact in our array
        NSNumber *contactIndex = nil;
        NSString *matchSource = [enhancedContact objectForKey:@"matchSource"];
        
        if ([matchSource isEqualToString:@"email"] && [enhancedContact objectForKey:@"email"]) {
            NSString *email = [[enhancedContact objectForKey:@"email"] lowercaseString];
            contactIndex = [contactsByEmail objectForKey:email];
        } else if ([matchSource isEqualToString:@"name"] && [enhancedContact objectForKey:@"name"]) {
            NSString *name = [[enhancedContact objectForKey:@"name"] lowercaseString];
            contactIndex = [contactsByName objectForKey:name];
        }
        
        if (!contactIndex) {
            continue;  // No matching contact found
        }
        
        // Get our contact
        Contact *contact = self.contacts[[contactIndex intValue]];
        
        // Set Facebook ID
        contact.facebookId = [enhancedContact objectForKey:@"facebookId"];
        
        // Add Facebook data
        contact.facebookData = [enhancedContact objectForKey:@"facebookData"];
        
        // Add the tags
        NSArray *tags = [enhancedContact objectForKey:@"tags"];
        for (NSDictionary *tagDict in tags) {
            Tag *tag = [[Tag alloc] init];
            tag.name = [tagDict objectForKey:@"name"];
            tag.category = [tagDict objectForKey:@"category"];
            tag.source = [tagDict objectForKey:@"source"];
            
            [self addTag:tag toContact:contact];
            
            // Also track auto-generated tags
            if (![self.autoGeneratedTags containsObject:tag]) {
                [self.autoGeneratedTags addObject:tag];
            }
        }
    }
}

#pragma mark - Tag Management

- (void)addTag:(Tag *)tag toContact:(Contact *)contact {
    if (!contact.tags) {
        contact.tags = [NSMutableArray array];
    }
    
    // Check if tag already exists
    for (Tag *existingTag in contact.tags) {
        if ([existingTag.name isEqualToString:tag.name] && [existingTag.category isEqualToString:tag.category]) {
            return;  // Tag already exists
        }
    }
    
    // Add tag to contact
    [contact.tags addObject:tag];
    
    // Also add to tag index
    NSString *tagKey = [NSString stringWithFormat:@"%@|%@", tag.category, tag.name];
    NSMutableArray *contactsWithTag = [self.tagIndex objectForKey:tagKey];
    
    if (!contactsWithTag) {
        contactsWithTag = [NSMutableArray array];
        [self.tagIndex setObject:contactsWithTag forKey:tagKey];
    }
    
    if (![contactsWithTag containsObject:contact]) {
        [contactsWithTag addObject:contact];
    }
}

- (void)generateTagsFromContact:(Contact *)contact {
    // This generates tags from basic contact info
    
    // Organization tag
    if (contact.organization.length > 0) {
        Tag *orgTag = [[Tag alloc] init];
        orgTag.name = contact.organization;
        orgTag.category = @"workplace";
        orgTag.source = @"contacts";
        [self addTag:orgTag toContact:contact];
    }
    
    // Job title tag
    if (contact.jobTitle.length > 0) {
        Tag *jobTag = [[Tag alloc] init];
        jobTag.name = contact.jobTitle;
        jobTag.category = @"profession";
        jobTag.source = @"contacts";
        [self addTag:jobTag toContact:contact];
    }
}

- (NSArray *)getTagsForContact:(Contact *)contact {
    return contact.tags;
}

- (NSArray *)getContactsWithTag:(Tag *)tag {
    NSString *tagKey = [NSString stringWithFormat:@"%@|%@", tag.category, tag.name];
    return [self.tagIndex objectForKey:tagKey];
}

- (NSArray *)filterContactsByTags:(NSArray *)tags {
    if (tags.count == 0) {
        return self.contacts;
    }
    
    NSMutableArray *filteredContacts = [NSMutableArray array];
    
    for (Contact *contact in self.contacts) {
        BOOL matchesAllTags = YES;
        
        for (Tag *filterTag in tags) {
            BOOL hasTag = NO;
            
            for (Tag *contactTag in contact.tags) {
                if ([contactTag.name isEqualToString:filterTag.name] && 
                    [contactTag.category isEqualToString:filterTag.category]) {
                    hasTag = YES;
                    break;
                }
            }
            
            if (!hasTag) {
                matchesAllTags = NO;
                break;
            }
        }
        
        if (matchesAllTags) {
            [filteredContacts addObject:contact];
        }
    }
    
    return filteredContacts;
}

#pragma mark - Storage

- (void)saveContactsToLocalStorage {
    // Archive contacts array to user defaults
    NSData *contactsData = [NSKeyedArchiver archivedDataWithRootObject:self.contacts];
    [[NSUserDefaults standardUserDefaults] setObject:contactsData forKey:@"BeeTagged_Contacts"];
    
    // Archive tag index
    NSData *tagIndexData = [NSKeyedArchiver archivedDataWithRootObject:self.tagIndex];
    [[NSUserDefaults standardUserDefaults] setObject:tagIndexData forKey:@"BeeTagged_TagIndex"];
    
    [[NSUserDefaults standardUserDefaults] synchronize];
}

- (void)loadContactsFromLocalStorage {
    // Load contacts
    NSData *contactsData = [[NSUserDefaults standardUserDefaults] objectForKey:@"BeeTagged_Contacts"];
    if (contactsData) {
        NSArray *loadedContacts = [NSKeyedUnarchiver unarchiveObjectWithData:contactsData];
        if (loadedContacts) {
            self.contacts = [NSMutableArray arrayWithArray:loadedContacts];
        }
    }
    
    // Load tag index
    NSData *tagIndexData = [[NSUserDefaults standardUserDefaults] objectForKey:@"BeeTagged_TagIndex"];
    if (tagIndexData) {
        NSDictionary *loadedTagIndex = [NSKeyedUnarchiver unarchiveObjectWithData:tagIndexData];
        if (loadedTagIndex) {
            self.tagIndex = [NSMutableDictionary dictionaryWithDictionary:loadedTagIndex];
        }
    }
    
    // Load Facebook token
    NSString *savedToken = [[NSUserDefaults standardUserDefaults] objectForKey:@"BeeTagged_FacebookAccessToken"];
    if (savedToken) {
        _facebookAccessToken = savedToken;
    }
}

- (void)clearAllData {
    [self.contacts removeAllObjects];
    [self.tagIndex removeAllObjects];
    [self.autoGeneratedTags removeAllObjects];
    [self clearFacebookAccessToken];
    
    // Clear from defaults
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"BeeTagged_Contacts"];
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"BeeTagged_TagIndex"];
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"BeeTagged_FacebookAccessToken"];
    [[NSUserDefaults standardUserDefaults] synchronize];
}

@end
