// Enhanced LinkedIn Data Processor with Semantic Search
// Add to your existing index.js

const OpenAI = require('openai'); // npm install openai
const similarity = require('compute-cosine-similarity'); // npm install compute-cosine-similarity

// Initialize OpenAI (add to your existing code)
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Enhanced Contact Schema (update your existing schema)
const enhancedContactSchema = new mongoose.Schema({
  // Existing fields
  name: { type: String, required: true, index: true },
  email: { type: String, default: '', index: true },
  phoneNumber: { type: String, default: '', index: true },
  company: { type: String, default: '', index: true },
  jobTitle: { type: String, default: '' },
  location: { type: String, default: '', index: true },
  
  // Enhanced LinkedIn fields
  linkedinProfile: { type: String, default: '' },
  currentPosition: {
    title: String,
    company: String,
    startDate: String,
    description: String
  },
  
  // Professional history
  experience: [{
    company: String,
    title: String,
    startDate: String,
    endDate: String,
    description: String,
    location: String
  }],
  
  // Education background
  education: [{
    school: String,
    degree: String,
    startYear: String,
    endYear: String,
    activities: String,
    notes: String
  }],
  
  // Skills and interests extracted from descriptions
  skills: [String],
  interests: [String],
  industries: [String],
  
  // AI-generated fields
  embedding: [Number], // Vector embedding for semantic search
  personality_traits: [String], // Extracted from descriptions
  career_stage: String, // junior, mid, senior, executive
  expertise_areas: [String], // Tech, Marketing, Sales, etc.
  
  // Search optimization
  searchableText: { type: String, default: '' },
  lastEmbeddingUpdate: { type: Date, default: Date.now },
  
  // Metadata
  userId: { type: String, default: null, index: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// Create indexes for semantic search
enhancedContactSchema.index({ embedding: 1 });
enhancedContactSchema.index({ skills: 1 });
enhancedContactSchema.index({ expertise_areas: 1 });
enhancedContactSchema.index({ industries: 1 });

const EnhancedContact = mongoose.model('EnhancedContact', enhancedContactSchema);

// LinkedIn Data Parser Functions
class LinkedInDataProcessor {
  
  // Parse Education data
  parseEducation(educationText) {
    const lines = educationText.split('\n').slice(1); // Skip header
    return lines.map(line => {
      const parts = line.split('\t');
      return {
        school: parts[0] || '',
        startYear: parts[1] || '',
        endYear: parts[2] || '',
        notes: parts[3] || '',
        degree: parts[4] || '',
        activities: parts[5] || ''
      };
    }).filter(edu => edu.school); // Only include entries with school names
  }

  // Parse Positions/Experience data  
  parsePositions(positionsText) {
    const lines = positionsText.split('\n').slice(1); // Skip header
    return lines.map(line => {
      const parts = line.split('\t');
      return {
        company: parts[0] || '',
        title: parts[1] || '',
        description: parts[2] || '',
        location: parts[3] || '',
        startDate: parts[4] || '',
        endDate: parts[5] || ''
      };
    }).filter(pos => pos.company); // Only include entries with company names
  }

  // Extract skills from job descriptions using NLP patterns
  extractSkills(text) {
    const skillPatterns = [
      /\b(JavaScript|Python|React|Node\.js|TypeScript|SQL|MongoDB|AWS|Azure|Docker|Kubernetes)\b/gi,
      /\b(Marketing|Sales|Analytics|Strategy|Operations|Finance|HR|Legal)\b/gi,
      /\b(Machine Learning|AI|Data Science|Analytics|Business Intelligence)\b/gi,
      /\b(Leadership|Management|Team Building|Cross-functional|Project Management)\b/gi
    ];
    
    const skills = new Set();
    skillPatterns.forEach(pattern => {
      const matches = text.match(pattern) || [];
      matches.forEach(match => skills.add(match.toLowerCase()));
    });
    
    return Array.from(skills);
  }

  // Extract interests and personality traits
  extractInterests(text) {
    const interestPatterns = [
      /\b(chess|soccer|basketball|hiking|photography|music|travel|cooking)\b/gi,
      /\b(entrepreneurship|startups|innovation|technology|sustainability)\b/gi,
      /\b(volunteer|community|nonprofit|social impact|mentoring)\b/gi
    ];
    
    const interests = new Set();
    interestPatterns.forEach(pattern => {
      const matches = text.match(pattern) || [];
      matches.forEach(match => interests.add(match.toLowerCase()));
    });
    
    return Array.from(interests);
  }

  // Determine expertise areas based on experience
  determineExpertiseAreas(experience) {
    const expertiseMap = {
      'Product Marketing': ['marketing', 'product', 'go-to-market', 'positioning', 'messaging'],
      'Data Analytics': ['analytics', 'data', 'metrics', 'reporting', 'business intelligence'],
      'Sales Strategy': ['sales', 'revenue', 'pipeline', 'forecasting', 'account management'],
      'Entrepreneurship': ['founder', 'startup', 'entrepreneur', 'venture', 'innovation'],
      'Technology': ['software', 'platform', 'cloud', 'AI', 'automation', 'digital'],
      'Leadership': ['director', 'manager', 'team', 'leadership', 'strategy']
    };

    const expertise = new Set();
    const allText = experience.map(exp => `${exp.title} ${exp.description}`).join(' ').toLowerCase();

    Object.entries(expertiseMap).forEach(([area, keywords]) => {
      if (keywords.some(keyword => allText.includes(keyword))) {
        expertise.add(area);
      }
    });

    return Array.from(expertise);
  }

  // Create comprehensive profile from parsed data
  createEnhancedProfile(educationData, positionsData, userId = 'default') {
    const education = this.parseEducation(educationData);
    const experience = this.parsePositions(positionsData);
    
    // Get current position (most recent)
    const currentPosition = experience.length > 0 ? experience[0] : null;
    
    // Extract comprehensive text for embedding
    const allText = [
      ...education.map(edu => `${edu.school} ${edu.degree} ${edu.notes} ${edu.activities}`),
      ...experience.map(exp => `${exp.company} ${exp.title} ${exp.description}`)
    ].join(' ');

    const profile = {
      // Basic info
      name: "Your LinkedIn Profile", // Would come from Profile.csv if available
      userId: userId,
      
      // Current position
      currentPosition: currentPosition ? {
        title: currentPosition.title,
        company: currentPosition.company,
        startDate: currentPosition.startDate,
        description: currentPosition.description
      } : null,
      
      // Full experience and education
      experience: experience,
      education: education,
      
      // Extracted insights
      skills: this.extractSkills(allText),
      interests: this.extractInterests(allText),
      expertise_areas: this.determineExpertiseAreas(experience),
      
      // For location extraction - could be enhanced
      location: currentPosition?.location || '',
      
      // Searchable text for fallback search
      searchableText: allText,
      
      // Metadata
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return profile;
  }
}

// Generate embeddings using OpenAI
async function generateEmbedding(text) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      console.warn('OpenAI API key not configured, skipping embedding generation');
      return null;
    }

    const response = await openai.embeddings.create({
      model: "text-embedding-ada-002",
      input: text,
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    return null;
  }
}

// Enhanced semantic search function
async function semanticSearch(query, userId = null) {
  try {
    // Generate embedding for the search query
    const queryEmbedding = await generateEmbedding(query);
    
    if (!queryEmbedding) {
      // Fallback to text search
      return await textSearch(query, userId);
    }

    // Get all contacts with embeddings
    const contacts = await EnhancedContact.find({
      userId: userId,
      embedding: { $exists: true, $ne: [] }
    }).lean();

    // Calculate similarity scores
    const results = contacts.map(contact => ({
      ...contact,
      similarity: similarity(queryEmbedding, contact.embedding)
    }))
    .filter(contact => contact.similarity > 0.7) // Threshold for relevance
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, 20); // Top 20 results

    return results;
  } catch (error) {
    console.error('Semantic search error:', error);
    return await textSearch(query, userId);
  }
}

// Fallback text search
async function textSearch(query, userId = null) {
  const searchQuery = { $text: { $search: query } };
  if (userId) searchQuery.userId = userId;
  
  return await EnhancedContact.find(searchQuery)
    .limit(20)
    .sort({ score: { $meta: "textScore" } })
    .lean();
}

// Enhanced natural language search endpoint
app.get('/api/search-semantic', async (req, res) => {
  try {
    const { q: query, userId } = req.query;
    
    if (!query) {
      return res.status(400).json({ 
        error: 'Query parameter is required',
        contacts: [],
        count: 0
      });
    }

    console.log('Semantic search query:', query);
    
    // Use semantic search
    const results = await semanticSearch(query, userId);
    
    res.json({
      query: query,
      count: results.length,
      contacts: results,
      search_type: 'semantic'
    });

  } catch (error) {
    console.error('Semantic search error:', error);
    res.status(500).json({ 
      error: 'Search failed',
      contacts: [],
      count: 0
    });
  }
});

// Enhanced LinkedIn import endpoint
app.post('/api/import-linkedin-enhanced', async (req, res) => {
  try {
    const { educationData, positionsData, userId = 'default' } = req.body;
    
    if (!educationData || !positionsData) {
      return res.status(400).json({
        success: false,
        message: 'Both education and positions data required'
      });
    }

    const processor = new LinkedInDataProcessor();
    const profile = processor.createEnhancedProfile(educationData, positionsData, userId);

    // Generate embedding for the complete profile
    const embedding = await generateEmbedding(profile.searchableText);
    if (embedding) {
      profile.embedding = embedding;
    }

    // Save to database
    const savedProfile = await EnhancedContact.create(profile);

    res.json({
      success: true,
      message: 'LinkedIn profile imported successfully',
      profile: {
        id: savedProfile._id,
        name: savedProfile.name,
        skills: savedProfile.skills,
        expertise_areas: savedProfile.expertise_areas,
        experience_count: savedProfile.experience.length,
        education_count: savedProfile.education.length
      }
    });

  } catch (error) {
    console.error('LinkedIn import error:', error);
    res.status(500).json({
      success: false,
      message: 'Import failed',
      error: error.message
    });
  }
});

// Export the processor for use
module.exports = {
  LinkedInDataProcessor,
  EnhancedContact,
  generateEmbedding,
  semanticSearch
};